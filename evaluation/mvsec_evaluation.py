import os
import numpy as np
from utils.object_detection_eval import evaluatePascalVOCMetrics, computeTruePositives


class MVSECEvaluation:
    """Evalutes the output txt file generated by the code provided with the Network Grafting approach"""
    def __init__(self, ground_truth_path, prediction_path=None):
        self.ground_truth_path = ground_truth_path
        self.prediction_path = prediction_path

    def evaluate(self, predicted_bbox=None, ground_truth_bbox=None, dont_care_bbox=None):
        nr_classes = 2
        if ground_truth_bbox is None or dont_care_bbox is None:
            ground_truth_bbox, dont_care_bbox = self.extractGroundTruth()
        if predicted_bbox is None:
            predicted_bbox = self.extractPredictions()
        predicted_bbox = self.removeDontCarePredictions(predicted_bbox, dont_care_bbox)

        statistics_new = evaluatePascalVOCMetrics(ground_truth_bbox, predicted_bbox, nr_classes=nr_classes)
        print('mAP Car Class')
        print(statistics_new[0]['AP'])

    def extractGroundTruth(self):
        ground_truth_bbox = []
        dont_care_bbox = []

        ground_truth_file_list = os.listdir(self.ground_truth_path)
        ground_truth_file_list.sort()
        for file in ground_truth_file_list:
            with open(os.path.join(self.ground_truth_path, file)) as f:
                frame_list = []
                dont_care_frame_list = []
                for line in f:
                    splitted_line = line.split(' ')
                    y_min, x_min, y_max, x_max = float(splitted_line[-4]), float(splitted_line[-3]), \
                                                 float(splitted_line[-2]), float(splitted_line[-1])
                    if splitted_line[0] == 'Car':
                        class_id = 0
                        frame_list.append(np.array([x_min, y_min, x_max, y_max, class_id]))
                    elif splitted_line[0] == 'DontCare':
                        class_id = 0
                        dont_care_frame_list.append(np.array([x_min, y_min, x_max, y_max, class_id]))

            ground_truth_bbox.append(frame_list)
            dont_care_bbox.append(dont_care_frame_list)

        return ground_truth_bbox, dont_care_bbox

    def extractPredictions(self):
        predicted_bbox = []
        ground_truth_file_list = os.listdir(self.ground_truth_path)
        ground_truth_file_list.sort()

        pred_img_id = [int(file_name[:-4].split('_')[-1]) for file_name in os.listdir(self.prediction_path)]
        pred_img_id.sort()

        for file in ground_truth_file_list:
            gt_id = int(file[:-4].split('_')[-1])
            if gt_id not in pred_img_id:
                predicted_bbox.append([])
                continue

            pred_filename = 'frame_ev_pair_' + str(gt_id).zfill(5) + '.txt'
            with open(os.path.join(self.prediction_path, pred_filename)) as f:
                frame_list = []
                for line in f:
                    splitted_line = line.split(' ')
                    y_min, x_min, y_max, x_max, class_score = float(splitted_line[2]), float(splitted_line[3]), \
                                                              float(splitted_line[4]), float(splitted_line[5]), \
                                                              float(splitted_line[1])
                    frame_list.append(np.array([x_min, y_min, x_max, y_max, 0, class_score]))
            predicted_bbox.append(frame_list)
        return predicted_bbox

    def removeDontCarePredictions(self, predicted_bbox, dont_care_bbox):
        new_predicted_bbox = []
        for img_dont_care_bboxes, img_det_bboxes in zip(dont_care_bbox, predicted_bbox):
            if len(img_dont_care_bboxes) == 0:
                new_predicted_bbox.append(img_det_bboxes)
                continue
            if len(img_det_bboxes) == 0:
                new_predicted_bbox.append([])
                continue

            det_bboxs_array = np.array(img_det_bboxes)
            dont_care_bboxs_array = np.array(img_dont_care_bboxes)

            dont_care_overlap_bool = computeTruePositives(dont_care_bboxs_array, det_bboxs_array, IOUThreshold=0.5)

            new_predicted_bbox.append(det_bboxs_array[np.logical_not(dont_care_overlap_bool), :].tolist())

        return new_predicted_bbox
